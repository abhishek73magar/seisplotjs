<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8"/>
  <title>
   seisplotjs 2.0 Tutorial, p3
  </title>
  <meta content="Javascript library for parsing, manipulating and displaying seismic data." name="description"/>
  <meta content="width=device-width,initial-scale=1" name="viewport"/>
  <link href="../bass.css" rel="stylesheet"/>
  <link href="../split.css" rel="stylesheet"/>
  <link href="../prism.css" rel="stylesheet"/>
  <link href="style.css" rel="stylesheet"/>
 </head>
 <body>
  <div class="flex">
   <div class="overflow-auto fs0 height-viewport-100" id="split-left">
    <div class="py1 px2">
     <div id="toc">
      <ul class="list-reset h5 py1-ul">
       <li>
        <a class="" href="../index.html">
         Seisplotjs
        </a>
       </li>
       <li>
        <a class="" href="../api/index.html">
         API JS Docs
        </a>
       </li>
       <li><a href="../gallery/index.html" class="">Gallery</a></li>
       <li>
        <a class="" href="../examples/index.html">
         Examples
        </a>
       </li>
       <li>
        <a class="" href="../tutorial/index.html">
         Tutorial
        </a>
       </li>
       <li class="sub">
        <a class="sub" href="../tutorial/index.html">
         Sine Wave
        </a>
       </li>
       <li class="sub">
        <a class="sub" href="../tutorial/2_realdata.html">
         Real data
        </a>
       </li>
       <li class="sub">
        <a class="sub" href="../tutorial/3_quakesandchannels.html">
         Quakes and Channels
        </a>
       </li>
       <li class="sub">
        <a class="sub" href="../tutorial/4_arrivaltimes.html">
         Arrival Times
        </a>
       </li>
       <li class="sub">
        <a class="sub" href="../tutorial/5_filter.html">
         Filtering
        </a>
       </li>
       <li class="sub">
        <a class="sub" href="../tutorial/6_helicorder.html">
         Helicorder
        </a>
       </li>
       <li class="sub">
        <a class="sub" href="../tutorial/7_realtime.html">
         Realtime
        </a>
       </li>
       <li class="sub">
        <a class="sub" href="../tutorial/8_andmore.html">
         ...and more
        </a>
       </li>
      </ul>
     </div>
    </div>
   </div>
   <div class="relative overflow-auto height-viewport-100" id="split-right">
    <section class="p2 mb2 clearfix bg-white minishadow">
     <div class="clearfix">
      <h1>
       Seisplotjs Tutorial
      </h1>
      <h3>
       Quakes and Channels:
      </h3>
      <h5>
       See it live in
       <a href="tutorial3.html" target="_blank">
        tutorial3.html
       </a>
       .
      </h5>
      <p>
       It would be nicer if we could add some useful labels to this instead
            of just a raw seismogram. Perhaps getting some information about
            this particular earthquake and the station it was recorded at. We
            will use the IRIS
       <a href="http://service.iris.edu/fdsnws/station/1/">
        FDSNWS
            station
       </a>
       web service to get the station and channels and the USGS
       <a href="http://earthquake.usgs.gov/fdsnws/event/1/">
        FDSNWS
           event
       </a>
       web service to get the earthquake. Since we will have the
           locations for the quake and station, we might as well plot them on a
           map. We can use
       <a href="https://leafletjs.com">
        Leaflet
       </a>
       , a
           javascript map library
           that creates nice looking maps and has lots of flexibility, for this.
           Seisplotjs includes leaflet and provides helper functions in the
       <code class="language-javascript">
        seisplotjs.leafletutil
       </code>
       module.
      </p>
      <p>
       We can add some additional styling to size the map. Because the quake and
            the station are more or less east west of each other, we can use a
            map that is relatively narrow vertically, but spans the entire window.
            The markers on the map can also be styled with css, using the
       <code class="language-javascript">
        quakeMarker
       </code>
       and
       <code class="language-javascript">
        stationMarker
       </code>
       selectors. We
        will change the color from the default red and blue to illustrate. Note
        that the station icon is actually a div that contains a triangle
        unicode character, \u25B2, while the quake marker is a circle created
        from an svg path element and so we use stoke and fill instead of color.
      </p>
      <pre><code class="language-css">
          &lt;style&gt;
            div#mapid {
              height: 300px;
              width: 100%;
            }
            div.stationMapMarker {
              color: rebeccapurple;
            }
            path.quakeMapMarker {
              fill: orange;
              stroke: yellow;
              fill-opacity: 0.25;
            }
          &lt;/style&gt;
        </code></pre>
      <p>
       First, we will create the map, centering it on 35/-100 and at
       zoom level 4. The
       <a href="https://services.arcgisonline.com/ArcGIS/rest/services/Ocean/World_Ocean_Base/MapServer">
        World Ocean Base
       </a>
       tile layer gives a nice background.
      </p>
      <pre><code class="language-javascript" snippet="map">
import {
  fdsndataselect, fdsnevent, fdsnstation,
  seismogram, seismograph,
  seismographconfig,
  stationxml,
  util, luxon} from './seisplotjs_3.0.0-alpha.1_standalone.mjs';

const mymap = document.querySelector('sp-station-event-map');
//mymap.scrollWheelZoom.disable();


</code></pre>
      <p>
       Then we will create the queries for the quake and station.
        Again, both of these queries
        are asynchronous and so we will have to use promises. We first create
        both the
       <code class="language-javascript">
        EventQuery
       </code>
       and
       <code class="language-javascript">
        StationQuery
       </code>
       objects.
      </p>
      <pre><code class="language-javascript" snippet="quakechan">
let queryTimeWindow = luxon.Interval.fromDateTimes(util.isoToDateTime('2019-07-01'), util.isoToDateTime('2019-07-31'));
let eventQuery = new fdsnevent.EventQuery()
  .timeWindow(queryTimeWindow)
  .minMag(7)
  .latitude(35).longitude(-118)
  .maxRadius(3);
let stationQuery = new fdsnstation.StationQuery()
  .networkCode('CO')
  .stationCode('HODGE')
  .locationCode('00')
  .channelCode('LH?')
  .timeWindow(queryTimeWindow);
</code></pre>
      <p>
       Next we call the
       <code class="language-javascript">
        query
       </code>
       methods for eventQuery and stationQuery, which each
       return a Promise to an array of Network or Quake objects
       and then use those to plot the earthquakes and stations on the map.
       The station will be plotted as
       a generic triangle as the map marker, but the quake is
       plotted as a circle with the radius scaled by the magnitude.
       We also added a couple of
       <code class="language-html">
        &lt;span&gt;
       </code>
       elements to hold the station codes and earthquake description.
        We set the these elements assuming we will only get one of each.
      </p>
      <pre><code class="language-javascript" snippet="promise">
let stationsPromise = stationQuery.queryChannels();
let quakePromise = eventQuery.query();
</code></pre>
      <p>
       We then use a separate
       <code class="language-javascript">
        then()
       </code>
       for the actual seismograms. Because we will need both the earthquake and
       the chanenls, we use
       <code class="language-javascript">
        Promise.all()
       </code>
       to ensure both have successfully completed.
       We then will use the more powerful POST method of the
       <a href="http://service.iris.edu/fdsnws/dataselect/1/">
        FDSNWS dataselect
       </a>
       web
       service to get the seismograms.
       The array of
       <code class="language-javascript">
        SeismogramDisplayData
       </code>
       objects works just like the
       <code class="language-javascript">
        StartEndDuration
       </code>
       we saw previously but also holds the channel and the quake and will also contain
          the resulting seismogram. We ask for data starting at the origin time of the
          earthquake and with a duration of 2400 seconds.
      </p>
      <pre><code class="language-javascript" snippet="seismogramload">
Promise.all( [ quakePromise, stationsPromise ] )
.then( ( [ quakeList, networkList ] ) =&gt; {
  let seismogramDataList = [];
  for (const q of quakeList) {
    let timeWindow = luxon.Interval.after(q.time, luxon.Duration.fromMillis(1000*2400));
    for (const c of stationxml.allChannels(networkList)) {
      let sdd = seismogram.SeismogramDisplayData.fromChannelAndTimeWindow(c, timeWindow);
      sdd.addQuake(q);
      seismogramDataList.push(sdd);
    }
  }
  mymap.seisData = seismogramDataList;
  mymap.seisData.forEach(sdd =&gt; {
    console.log(`${sdd.quakeList.length}  ${sdd.quake}`);
  })
  let dsQuery = new fdsndataselect.DataSelectQuery();
  let sddPromise = dsQuery.postQuerySeismograms(seismogramDataList);
  return Promise.all( [ quakePromise, stationsPromise, sddPromise ] );
</code></pre>
      <p>
       Once these are loaded we will plot them
        just like we did before. Because we have the
        channel, we can also plot the seismograms corrected for overall
        gain and in units of m/s.
        The default text coloring colors the seismograms and the corresponding
        array of strings in the title the same color, making them easier to
        identify. Note the units on the left hand side are now m/s.
      </p>
      <pre><code class="language-javascript" snippet="seismogramplot">
}).then( ( [ quakeList, networkList, seismogramDataList ] ) =&gt; {
    let div = document.querySelector('div#myseismograph');
    let seisConfig = new seismographconfig.SeismographConfig();
    seisConfig.doGain = false;
    seisConfig.centeredAmp = true;
    let graphCount = new seismograph.Seismograph(seismogramDataList, seisConfig);
    div.appendChild(graphCount);

    let seisConfigGain = new seismographconfig.SeismographConfig();
    seisConfigGain.doGain = true;
    seisConfigGain.centeredAmp = true;
    let graphGain = new seismograph.Seismograph(seismogramDataList, seisConfigGain);
    div.appendChild(graphGain);
    return seismogramDataList;
}).catch( function(error) {
  const div = document.querySelector('div#myseismograph');
  div.innerHTML = `
    &lt;p&gt;Error loading data. ${error}&lt;/p&gt;
  `;
  console.assert(false, error);
});
</code></pre>
      <h3>
       See it live in
       <a href="tutorial3.html" target="_blank">
        tutorial3.html
       </a>
       .
      </h3>
      <p>
       Previous:
       <a href="2_realdata.html">
        Let"s get some real data
       </a>
      </p>
      <p>
       Next:
       <a href="4_arrivaltimes.html">
        Predicted phase arrival times
       </a>
      </p>
     </div>
    </section>
   </div>
  </div>
  <script src="../prism.js">
  </script>
  <script>
   Prism.plugins.NormalizeWhitespace.setDefaults({
      	"remove-trailing": true,
      	"remove-indent": true,
      	"left-trim": true,
      	"right-trim": true
      });
  </script>
 </body>
</html>
