<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8"/>
  <title>
   seisplotjs 2.0 Tutorial, p5
  </title>
  <meta content="Javascript library for parsing, manipulating and displaying seismic data." name="description"/>
  <meta content="width=device-width,initial-scale=1" name="viewport"/>
  <link href="../bass.css" rel="stylesheet"/>
  <link href="../split.css" rel="stylesheet"/>
  <link href="../prism.css" rel="stylesheet"/>
  <link href="style.css" rel="stylesheet"/>
 </head>
 <body>
  <div class="flex">
   <div class="overflow-auto fs0 height-viewport-100" id="split-left">
    <div class="py1 px2">
     <div id="toc">
      <ul class="list-reset h5 py1-ul">
       <li>
        <a class="" href="../index.html">
         Seisplotjs
        </a>
       </li>
       <li>
        <a class="" href="../api/index.html">
         API JS Docs
        </a>
       </li>
       <li>
        <a class="" href="../examples/index.html">
         Examples
        </a>
       </li>
       <li>
        <a class="" href="../tutorial/index.html">
         Tutorial
        </a>
       </li>
       <li class="sub">
        <a class="sub" href="../tutorial/index.html">
         Sine Wave
        </a>
       </li>
       <li class="sub">
        <a class="sub" href="../tutorial/2_realdata.html">
         Real data
        </a>
       </li>
       <li class="sub">
        <a class="sub" href="../tutorial/3_quakesandchannels.html">
         Quakes and Channels
        </a>
       </li>
       <li class="sub">
        <a class="sub" href="../tutorial/4_arrivaltimes.html">
         Arrival Times
        </a>
       </li>
       <li class="sub">
        <a class="sub" href="../tutorial/5_filter.html">
         Filtering
        </a>
       </li>
       <li class="sub">
        <a class="sub" href="../tutorial/6_helicorder.html">
         Helicorder
        </a>
       </li>
       <li class="sub">
        <a class="sub" href="../tutorial/7_realtime.html">
         Realtime
        </a>
       </li>
       <li class="sub">
        <a class="sub" href="../tutorial/8_andmore.html">
         ...and more
        </a>
       </li>
      </ul>
     </div>
    </div>
   </div>
   <div class="relative overflow-auto height-viewport-100" id="split-right">
    <section class="p2 mb2 clearfix bg-white minishadow">
     <div class="clearfix">
      <h1>
       Seisplotjs Tutorial
      </h1>
      <h3>
       Filtering, Deconvolution and FFT
      </h3>
      <h5>
       See it live in
       <a href="tutorial5.html" target="_blank">
        tutorial5.html
       </a>
       .
      </h5>
      <p>
       Maybe we would like to see the body waves more clearly and filter out
            the surface waves. And instead of the raw velocity data, lets
            apply the full instrument response to correct to displacement.
            First, lets switch from the LH? channels, recorded
            at one sample per second, to the HH? channels, recorded at 100 sps
            to give us a wider frequency band to play with. Since we will need
            the response information as well, we will need to change from
            using
       <code class="language-javascript">
        queryChannels()
       </code>
       to
       <code class="language-javascript">
        queryResponses()
       </code>
       in the
       <code class="language-javascript">
        stationQuery
       </code>
       . This will return stationXML with the full response filled in for each
        channel. We can also the time window used in our dataselect query
        to use offsets from the predicted arrivals, windowing in on just the
        range we need around the P wave.
        This is all possible by modifying the functionality
        shown in the previous tutorial. However, because getting seismograms
        for an earthquake at a channel based on predicted arrival times is
        such a common activity, there is a tool,
       <code class="language-javascript">
        SeismogramLoader
       </code>
       that does this for us.
      </p>
      <p>
       The first steps will look a lot like the previous tutorial, where we
        set up the stationQuery and eventQuery with our search parameters.
      </p>
      <pre><code class="language-javascript" snippet="eventandstation">
let queryTimeWindow = new seisplotjs.util.StartEndDuration('2019-07-01', '2019-07-31');
let eventQuery = new seisplotjs.fdsnevent.EventQuery()
  .timeWindow(queryTimeWindow)
  .minMag(7)
  .latitude(35).longitude(-118)
  .maxRadius(3);
let stationQuery = new seisplotjs.fdsnstation.StationQuery()
  .networkCode('CO')
  .stationCode('HODGE')
  .locationCode('00')
  .channelCode('HH?')
  .timeWindow(queryTimeWindow);
</code></pre>
      <p>
       Of course 100 sps means that we will have 100 times as many samples, so
            lets reduce the time window to just the region where the P
            arrival is, say 300 seconds instead of 1800.
      </p>
      <pre><code class="language-javascript" snippet="loaderinit">
let loader = new seisplotjs.seismogramloader.SeismogramLoader(stationQuery, eventQuery);
loader.startOffset = -30;
loader.endOffset = 270;
loader.markedPhaseList = "origin,PP,pP";
loader.withResponse = true;
let loaderSDDPromise = loader.loadSeismograms();

</code></pre>
      <p>
       We are not displaying maps here, but if we were then we can add a then
        function on loader.stationList and loader.quakeList, which are both
        Promises set up by the loadSeismograms method. These are useful when
        we need direct access to intermediate values as SeismogramLoader
        works across the various remote call. We can set the text in the
        span elements here just as an example. Note that the quake and channel
        are saved within the list of SeismogramDisplayData objects
        we will get at the end, so they are not lost even if we do not make
        use of these extra then methods.
      </p>
      <pre><code class="language-javascript" snippet="map">
let stationsPromise = loader.networkList.then(networkList =&gt; {
  let staText = "";
  for (let s of seisplotjs.stationxml.allStations(networkList)) {
    staText += s.codes();
  }
  seisplotjs.d3.select('span#stationCode').text(staText);
});
let quakePromise = loader.quakeList.then( quakeList =&gt; {
  let quakeText="";
  for (const q of quakeList) {
    quakeText+=quakeList[0].description+" ";
  }
  seisplotjs.d3.select('span#earthquakeDescription').text(quakeText);
});
</code></pre>
      <p>
       Now we insert the filtering code after the seismograms have arrived
        but before we plot them. We will insert another
       <code class="language-javascript">
        then()
       </code>
       call on the actual loader Promise. We create a butterworth
        filter using the sampling rate of the seismogram, with a passband
        of 0.5 to 10 Hz. Removing the mean is usually a good idea, then
        we apply the filter. Tapering is important before a deconvolution
        and then we
       <code class="language-javascript">
        transfer
       </code>
       the instrument response for the channel.
      </p>
      <pre><code class="language-javascript" snippet="filter">
loaderSDDPromise.then((seismogramDataList) =&gt; {
    seismogramDataList.forEach(sdd =&gt; {
      let butterworth = seisplotjs.filter.createButterworth(
                             2, // poles
                             seisplotjs.filter.BAND_PASS,
                             .5, // low corner
                             10, // high corner
                             1/sdd.seismogram.sampleRate // delta (period)
                    );
      let rmeanSeis = seisplotjs.filter.rMean(sdd.seismogram);
      let filteredSeis = seisplotjs.filter.applyFilter(butterworth, rmeanSeis);
      let taperSeis = seisplotjs.taper.taper(filteredSeis);
      let correctedSeis = seisplotjs.transfer.transfer(taperSeis,
          sdd.channel.response, .001, .02, 250, 500);
      sdd.seismogram = correctedSeis;
    });
    return seismogramDataList ;
</code></pre>
      Configure the display so that the amplitude and time axis are linked.
      <pre><code class="language-javascript" snippet="seisconfig">
  }).then( seismogramDataList  =&gt; {
    let div = document.querySelector('div#myseismograph');
    let seisConfig = new seisplotjs.seismographconfig.SeismographConfig();
    seisConfig.linkedTimeScale = new seisplotjs.scale.LinkedTimeScale();
    seisConfig.linkedAmplitudeScale = new seisplotjs.scale.LinkedAmplitudeScale();
    seisConfig.wheelZoom = false;
</code></pre>
      <p>
       Then, just to make sure we don"t correct the data twice, we
            disable the gain correction and create the plots.
      </p>
      <pre><code class="language-javascript" snippet="gain">
    seisConfig.doGain = false;
    seisConfig.doRMean = false;
    for( let sdd of seismogramDataList) {
      let graph = new seisplotjs.seismograph.Seismograph([sdd],
                                                         seisConfig);
      div.appendChild(graph);
    }
    return seismogramDataList;
</code></pre>
      <p>
       We can also plot the amplitude spectra for the
            three seismograms. We need to add an additional div to hold them.
      </p>
      <pre><code class="language-html">
            &lt;div id="fftplot"&gt;
            &lt;/div&gt;
          </code></pre>
      <p>
       And an additional style to size it.
      </p>
      <pre><code class="language-css">
            div#fftplot {
              height: 600px;
            }
          </code></pre>
      <p>
       Then we calculate the fft and plot it.
      </p>
      <pre><code class="language-javascript" snippet="fft">
  }).then(seismogramDataList =&gt; {
    let div = seisplotjs.d3.select('div#fftplot');
    let fftList = seismogramDataList.map(sdd =&gt; {
      if (sdd.seismogram.isContiguous()) {
        return seisplotjs.fft.fftForward(sdd.seismogram)
      } else {
        return null; // can't do fft for non-contiguouus
      }
    }).filter(x =&gt; x); // to remove nulls
    let seisConfig = new seisplotjs.seismographconfig.SeismographConfig();
    let fftPlot = new seisplotjs.spectraplot.SpectraPlot(fftList, seisConfig);
    document.querySelector('div#fftplot').appendChild(fftPlot);
    return seismogramDataList;
  });

</code></pre>
      <p>
       Then just a little bit of cleanup to make sure everything finished correctly.
      </p>
      <pre><code class="language-javascript" snippet="cleanup">
Promise.all( [ quakePromise, stationsPromise, loaderSDDPromise ] )
.catch( function(error) {
    seisplotjs.d3.select("div#myseismograph").append('p').html("Error loading data." +error);
    console.assert(false, error);
  });
</code></pre>
      <h3>
       See it live in
       <a href="tutorial5.html" target="_blank">
        tutorial5.html
       </a>
       .
      </h3>
      <p>
       Previous:
       <a href="4_arrivaltimes.html">
        Predicted phase arrival times
       </a>
      </p>
      <p>
       Next:
       <a href="6_helicorder.html">
        Helicorder
       </a>
      </p>
     </div>
    </section>
   </div>
  </div>
  <script src="../prism.js">
  </script>
  <script>
   Prism.plugins.NormalizeWhitespace.setDefaults({
      	"remove-trailing": true,
      	"remove-indent": true,
      	"left-trim": true,
      	"right-trim": true
      });
  </script>
 </body>
</html>
