<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8"/>
  <title>
   seisplotjs 2.0 Tutorial, p4
  </title>
  <meta content="Javascript library for parsing, manipulating and displaying seismic data." name="description"/>
  <meta content="width=device-width,initial-scale=1" name="viewport"/>
  <link href="../bass.css" rel="stylesheet"/>
  <link href="../split.css" rel="stylesheet"/>
  <link href="../prism.css" rel="stylesheet"/>
  <link href="style.css" rel="stylesheet"/>
 </head>
 <body>
  <div class="flex">
   <div class="overflow-auto fs0 height-viewport-100" id="split-left">
    <div class="py1 px2">
     <div id="toc">
      <ul class="list-reset h5 py1-ul">
       <li>
        <a class="" href="../index.html">
         Seisplotjs
        </a>
       </li>
       <li>
        <a class="" href="../api/index.html">
         API JS Docs
        </a>
       </li>
       <li>
        <a class="" href="../examples/index.html">
         Examples
        </a>
       </li>
       <li>
        <a class="" href="../tutorial/index.html">
         Tutorial
        </a>
       </li>
       <li class="sub">
        <a class="sub" href="../tutorial/index.html">
         Sine Wave
        </a>
       </li>
       <li class="sub">
        <a class="sub" href="../tutorial/2_realdata.html">
         Real data
        </a>
       </li>
       <li class="sub">
        <a class="sub" href="../tutorial/3_quakesandchannels.html">
         Quakes and Channels
        </a>
       </li>
       <li class="sub">
        <a class="sub" href="../tutorial/4_arrivaltimes.html">
         Arrival Times
        </a>
       </li>
       <li class="sub">
        <a class="sub" href="../tutorial/5_filter.html">
         Filtering
        </a>
       </li>
       <li class="sub">
        <a class="sub" href="../tutorial/6_helicorder.html">
         Helicorder
        </a>
       </li>
       <li class="sub">
        <a class="sub" href="../tutorial/7_realtime.html">
         Realtime
        </a>
       </li>
       <li class="sub">
        <a class="sub" href="../tutorial/8_andmore.html">
         ...and more
        </a>
       </li>
      </ul>
     </div>
    </div>
   </div>
   <div class="relative overflow-auto height-viewport-100" id="split-right">
    <section class="p2 mb2 clearfix bg-white minishadow">
     <div class="clearfix">
      <h1>
       Seisplotjs Tutorial
      </h1>
      <h3>
       Predicted Phase Arrival Times:
      </h3>
      <h5>
       See it live in
       <a href="tutorial4.html" target="_blank">
        tutorial4.html
       </a>
       .
      </h5>
      <p>
       It would be nice to know where the P and S wave are predicted to
            arrive. We can use the IRIS
       <a href="http://service.iris.edu/irisws/traveltime/1/">
        traveltime
       </a>
       web service to to get travel times for seismic phases. The traveltime
            web service uses
       <a href="http://www.seis.sc.edu/TauP/">
        The TauP Toolkit
       </a>
       under the hood, and so the documentation for it can help. We will
            keep things simple and just ask for
       <em>
        P
       </em>
       and
       <em>
        S
       </em>
       phases.
            Again, this is a remote service, therefore asynchronous, and we
            will need to
            use promises again. We put an additional
       <code class="language-javascript">
        then()
       </code>
       call
            after we get the quake and station but before we ask for the
            seismograms. This allows us to use the predicted travel times to
            pick the time window starting 30 seconds prior to the first P
            arrival.
      </p>
      <pre><code class="language-javascript" snippet="traveltime">
const loader = new seismogramloader.SeismogramLoader(stationQuery, eventQuery);
loader.startOffset = -300;
loader.endOffset = 1200;
loader.markedPhaseList = "PcP,SS";
loadPromise = loader.load();
dataset.Dataset.fromSeismogramLoader(loader).then(dataset =&gt; dataset.saveToZipFile());
} else {
  loadPromise = dataset.load('tutorial4_dataset.zip').then(ds =&gt; [ ds.inventory, ds.catalog, ds.waveforms]);
}
loadPromise.then(([ networkList, quakeList, seismogramDataList]) =&gt; {
  mymap.seisData = seismogramDataList;

console.log(`loaded ${seismogramDataList.length} sdd`)
  seismogramDataList.forEach(sdd =&gt; {
    console.log(sdd.traveltimeList.length);
    sdd.traveltimeList.forEach(tt =&gt; console.log(`tt: ${JSON.stringify(tt)}`));
  })

</code></pre>
      <p>
       Now in the next
       <code>
        then
       </code>
       , we can use add the travel time to the
            origin time to get a start for our request.
            The little flags for phase arrivals are
       <code>
        Marker
       </code>
       objects
            and we put them and the quake into our
       <code class="language-javascript">
        SeismogramDisplayData
       </code>
       objects.
            One important thing
            to keep in mind with time is that the moment objects from the
       <a href="https://momentjs.com/docs/">
        momentjs
       </a>
       library that we
            use are mutible, and so you should always create a copy before
            modifying like
       <code class="language-javascript">
        seisplotjs.moment.utc(quakeList[0].time)
       </code>
       as
            otherwise you will change the origin time of the quake. The
       <code class="language-javascript">
        postQuerySeismograms()
       </code>
       will parse the miniseed in the response and then create seismograms
            within each
       <code class="language-javascript">
        SeismogramDisplayData
       </code>
       object,
            making it easy to associate the new waveform with the request time
            window, channel, and quake.
      </p>
      <pre><code class="language-javascript" snippet="seismogramload">
let queryTimeWindow = new util.StartEndDuration('2019-07-01', '2019-07-31');
let eventQuery = new fdsnevent.EventQuery()
  .timeWindow(queryTimeWindow)
  .minMag(7)
  .latitude(35).longitude(-118)
  .maxRadius(3);
let stationQuery = new fdsnstation.StationQuery()
  .networkCode('CO')
  .stationCode('HODGE')
  .locationCode('00')
  .channelCode('LH?')
  .timeWindow(queryTimeWindow);
</code></pre>
      <p>
       Now that we have travel times and seismograms, we can plot both.
            We also link the seismographs so that they stay aligned with
            each other in time
            and amplitude.
      </p>
      <pre><code class="language-javascript" snippet="seismograph">
  let div = document.querySelector('div#myseismograph');
  let graphList = [];
  let commonSeisConfig = new seismographconfig.SeismographConfig();
  commonSeisConfig.linkedAmpScale = new scale.LinkedAmplitudeScale();
  commonSeisConfig.linkedTimeScale = new scale.LinkedTimeScale();
  commonSeisConfig.wheelZoom = false;
  commonSeisConfig.doGain = true;
  for( let sdd of seismogramDataList) {
    let seisConfig = commonSeisConfig.clone();
    let graph = new seismograph.Seismograph([ sdd ], seisConfig);
    graphList.push(graph);
    div.appendChild(graph);
  }
  return Promise.all([ quakeList, networkList, seismogramDataList, graphList ]);
</code></pre>
      <p>
       For a little extra, we also can plot the particle motion around the
            P wave for these seismograms. First we need to add a div to to the html.
      </p>
      <pre><code class="language-html">
            &lt;div  id="myparticlemotion"&gt;
            &lt;/div&gt;
          </code></pre>
      <p>
       And some styling in the &lt;style&gt; at the top.
      </p>
      <pre><code class="language-css">
          div.particlemotionContainer  {
            float:left;
            height: 300px;
            width: 320px;
          }
          </code></pre>
      <p>
       And then javascript to create the particle motion plots. This uses
        60 seconds around the S wave. We add some flags to the seismographs
        to show the time range plotted.
      </p>
      <pre><code class="language-javascript" snippet="particlemotion">
}).then( ( [ quakeList, networkList, seismogramDataList, graphList ] ) =&gt; {
  let pmdiv = document.querySelector("div#myparticlemotion");
  console.log(`pmdiv: ${pmdiv}`)
  let firstS = seismogramDataList[0].traveltimeList.find(a =&gt; a.phase.startsWith("S"));
  let windowDuration = 60;
  let firstSTimeWindow = new util.StartEndDuration(
    quakeList[0].time.plus({seconds: firstS.time,}).minus({seconds: windowDuration/4}),
    null,
    windowDuration);
  seismogramDataList.forEach(sdd =&gt; sdd.addMarkers({
    name: "pm start",
    time: firstSTimeWindow.startTime,
    type: "other",
    description: "pm start"}));
  seismogramDataList.forEach(sdd =&gt; sdd.addMarkers({
    name: "pm end",
    time: firstSTimeWindow.endTime,
    type: "other",
    description: "pm end"}));
  graphList.forEach(g =&gt; g.drawMarkers());
  let xSeisData = seismogramDataList[0].cut(firstSTimeWindow);
  let ySeisData = seismogramDataList[1].cut(firstSTimeWindow);
  let zSeisData = seismogramDataList[2].cut(firstSTimeWindow);

  let minMax = seismogram.findMinMax([ xSeisData, ySeisData, zSeisData]);
  let seisConfig = new particlemotion.createParticleMotionConfig(firstSTimeWindow);
  seisConfig.fixedYScale = minMax;
  let pmpA = new particlemotion.ParticleMotion(xSeisData, ySeisData, seisConfig);
  pmdiv.appendChild(pmpA);
  //pmpA.draw();
  let pmpB = new particlemotion.ParticleMotion(xSeisData, zSeisData, seisConfig);
  pmdiv.appendChild(pmpB);
  //pmpB.draw();
  let pmpC = new particlemotion.ParticleMotion(ySeisData, zSeisData, seisConfig);
  pmdiv.appendChild(pmpC);
  //pmpC.draw();

  return Promise.all([ quakeList, networkList, seismogramDataList, graphList ]);
}).catch( function(error) {
    const div = document.querySelector('div#myseismograph');
    div.innerHTML = `
      &lt;p&gt;Error loading data. ${error}&lt;/p&gt;
    `;
  console.assert(false, error);
});
</code></pre>
      <h3>
       See it live in
       <a href="tutorial4.html" target="_blank">
        tutorial4.html
       </a>
       .
      </h3>
      <p>
       Previous:
       <a href="3_quakesandchannels.html">
        Quakes and Channels
       </a>
      </p>
      <p>
       Next:
       <a href="5_filter.html">
        Deconvolution and Filtering
       </a>
      </p>
     </div>
    </section>
   </div>
  </div>
  <script src="../prism.js">
  </script>
  <script>
   Prism.plugins.NormalizeWhitespace.setDefaults({
      	"remove-trailing": true,
      	"remove-indent": true,
      	"left-trim": true,
      	"right-trim": true
      });
  </script>
 </body>
</html>
